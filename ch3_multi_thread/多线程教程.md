# VC++ 多线程实战图片编辑器

## 1 线程如何理解

>线程可以看作是操作系统分配给 CPU 时间（时间片）的基本单位。

在 Windows 中，操作系统创建了进程后，会创建主线程，然后由主线程创建其它子线程，一个进程的所有线程共享虚拟地址空间、全局变量及该进程的操作系统资源。Linux 中不需要为进程创建主线程获取 CPU 时间片，因此 Linux 中可以有多进程编程这种比较复杂的编程模式，需要用到 socket、信号量等通信机制，而多线程的通信通过变量就可以完成操作。

当进程被终止时，主线程也同时被终止，当主线程消亡时后，其子线程也同时消亡。但是在实际开发中经常发现主线程结束后，子线程没有结束，操作系统没有结束子线程，甚至出现不能释放子线程的情况。为了应对这种情况，在创建子线程的时候，一定要设置子线程的结束条件，不要依赖系统结束子线程，防止产生资源泄露及其它错误。

## 2 线程类的封装

一个对象代表新创建一个线程，一个线程对象本身是没有意义的，一定要设置一个工作函数指明线程所要进行的操作，即 usr_define_task(),声明为纯虚函数。这样直接子类对象会被提示实现 usr_define_task 函数。

不能把 usr_define_task 函数声明为线程的入口函数，即 _beginthread() 的第一个参数所需要的参数，这样会：1 破坏了封装，线程对象只能完成单一工作，而不同的任务要频繁更改基类的代码，没有发挥 OOP 的优势；2 报错，_beginthread 函数要求的实参类型函数原型是 void func(void*),在类中定义的函数的类型则属于 void (xthread:: *)( void*)，二者矛盾。正确的做法是在 xthread 的实现文件中声明一个静态函数作为线程函数入口函数（静态保证了只能在本 .cpp 文件中访问，不会被其它文件调用对数据进行非法操作），类内函数 start 负责线程的创建，进入该静态函数，在该静态函数中调用usr_define_task() 处理数据，并且在该静态函数内部结束线程。在子类继承后，重写 usr_define_task 函数实现。


## 3 线程类的挂起和恢复

挂起和恢复在实际应用中，除非是一开始适当的挂起，然后一起启动。正常情况下不太用这些功能，因为挂起的时候无法确定线程执行到哪里，在其它线程中调用函数挂起线程时可能被挂起的线程刚刚得到互斥资源，挂起后资源不释放，导致未知的错误。

## 4 线程同步

互斥访问静态资源或者互斥执行操作，操作不可打断。几乎是效率最高的线程同步方法。这部分封装了一个 xmutex 类，将临界区的初始化、进入、退出、删除返还系统这些操作都封装，这个例子很好地体现了　C++　面向对象封装的方便之处，需要好好消化。另外，同一个项目中有多个 main 函数用于不同实验的时候，在编译时除了保留一个 main 外，需要注意其它文件是不是定了同名称的子类、函数，编译时编译器不一定会采用 main 函数所在文件的定义，会造成莫名奇妙的错误，难以排查，最好将其它无关文件注释掉。

## 5 C++11 中的线程类

一般的线程启动、互斥已经有了定义，复杂的操作还需要借助系统 API 完成，另外，对于互斥、临界区的使用，遵循“晚使用，早退出”的原则，因为这类操作需要额外的系统开销，上述原则能保证系统开销最小。另外，早早地用 C++11 的 lock() 会出现找不到互斥操作变量的错误，在变量操作前使用 lock() 即可更正这类错误。

(完)



